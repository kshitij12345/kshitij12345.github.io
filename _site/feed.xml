<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-08-08T13:32:34+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hacker‚Äôs Getaway</title><subtitle>Rough slate</subtitle><author><name>Kshiteej</name><email>kshitijkalambarkar@gmail.com</email></author><entry><title type="html">Modern Effective C++: Chapter 2</title><link href="http://localhost:4000/c++/2021/07/17/Modern-Effective-C++-Chapter-2.html" rel="alternate" type="text/html" title="Modern Effective C++: Chapter 2" /><published>2021-07-17T14:14:49+05:30</published><updated>2021-07-17T14:14:49+05:30</updated><id>http://localhost:4000/c++/2021/07/17/Modern-Effective-C++-Chapter-2</id><content type="html" xml:base="http://localhost:4000/c++/2021/07/17/Modern-Effective-C++-Chapter-2.html">&lt;h3 id=&quot;chapter-2--auto&quot;&gt;Chapter 2 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Item 5: Prefer auto to explicit type declarations.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt; whenever possible (helps you from explicitly adding the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;types&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Also, it helps avoid few errors
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt; doesn‚Äôt support uninitialized variables. Unlike &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int x&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; is uninitialized, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto x;&lt;/code&gt; is not valid! It has to be either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto x{1}&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto x = 1;&lt;/code&gt; (1 is just some random value in this example)&lt;/li&gt;
      &lt;li&gt;It helps to easily take get the value type of iterator objects. Replace &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typename std::iterator_traits&amp;lt;It&amp;gt;::value_type
 currValue = *b;&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto currValue = *b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;For entities like lambda, their type is only known to compiler so how on earth can you make a variable for it using explicit type? &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt; to the rescue üòâ&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Also helps avoid subtle bugs (example: unsigned len = vec.size(), return type of vec.size() is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::vector&amp;lt;T&amp;gt;::size_type&lt;/code&gt;, however  since unsigned is platform dependent it can lead to bugs if it doesn‚Äôt match &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::vector&amp;lt;T&amp;gt;::size_type&lt;/code&gt;) (Refer example on page 40 which talks about vec.size() )&lt;/li&gt;
  &lt;li&gt;Can avoid temporary object creation (Refer example on page 40 which talks about unordered map)&lt;/li&gt;
  &lt;li&gt;For people worried about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt; decreasing the readability should note that tons of succesful language have type inference where user doesn‚Äôt need to explicitly specify the types. Also IDE and editor can/should help reveal the type.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Item 6:  Use the explicitly typed initializer idiom when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt; deduces undesired types.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For some edge-cases, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt; may deduce type which you don‚Äôt actually want, in that case you should use the &lt;strong&gt;explicitly type initializer&lt;/strong&gt; idiom. Eg. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto x = static_cast&amp;lt;float&amp;gt;(get_double_eps())&lt;/code&gt;, this approach is better than implicitly converting to float using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float x = get_double_eps()&lt;/code&gt;. Also this will help you to get around the functions or interface which return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy&lt;/code&gt; object (as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt; will deduce the type to be proxy object and not the type it is acting as proxy for). Proxy objects are those which behave like a certain type but are not of that type. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::vector::operator[]&lt;/code&gt; returns proxy object (as reference to bits is not valid). (Refer to Item 6 in book for gory details üòÑ )&lt;/li&gt;
  &lt;li&gt;Prefer explicit cast over implicit cast!&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Kshiteej</name><email>kshitijkalambarkar@gmail.com</email></author><category term="c++" /><summary type="html">Chapter 2 : auto Item 5: Prefer auto to explicit type declarations. Use auto whenever possible (helps you from explicitly adding the types) Also, it helps avoid few errors auto doesn‚Äôt support uninitialized variables. Unlike int x where x is uninitialized, auto x; is not valid! It has to be either auto x{1} or auto x = 1; (1 is just some random value in this example) It helps to easily take get the value type of iterator objects. Replace typename std::iterator_traits&amp;lt;It&amp;gt;::value_type currValue = *b; -&amp;gt; auto currValue = *b For entities like lambda, their type is only known to compiler so how on earth can you make a variable for it using explicit type? auto to the rescue üòâ Also helps avoid subtle bugs (example: unsigned len = vec.size(), return type of vec.size() is std::vector&amp;lt;T&amp;gt;::size_type, however since unsigned is platform dependent it can lead to bugs if it doesn‚Äôt match std::vector&amp;lt;T&amp;gt;::size_type) (Refer example on page 40 which talks about vec.size() ) Can avoid temporary object creation (Refer example on page 40 which talks about unordered map) For people worried about auto decreasing the readability should note that tons of succesful language have type inference where user doesn‚Äôt need to explicitly specify the types. Also IDE and editor can/should help reveal the type. Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types. For some edge-cases, auto may deduce type which you don‚Äôt actually want, in that case you should use the explicitly type initializer idiom. Eg. auto x = static_cast&amp;lt;float&amp;gt;(get_double_eps()), this approach is better than implicitly converting to float using float x = get_double_eps(). Also this will help you to get around the functions or interface which return proxy object (as auto will deduce the type to be proxy object and not the type it is acting as proxy for). Proxy objects are those which behave like a certain type but are not of that type. std::vector::operator[] returns proxy object (as reference to bits is not valid). (Refer to Item 6 in book for gory details üòÑ ) Prefer explicit cast over implicit cast!</summary></entry><entry><title type="html">GPU Parallel Programming: Chapter 1</title><link href="http://localhost:4000/c++,/cuda/2021/07/17/GPU-Parallel-Chapter-1.html" rel="alternate" type="text/html" title="GPU Parallel Programming: Chapter 1" /><published>2021-07-17T14:14:49+05:30</published><updated>2021-07-17T14:14:49+05:30</updated><id>http://localhost:4000/c++,/cuda/2021/07/17/GPU-Parallel-Chapter-1</id><content type="html" xml:base="http://localhost:4000/c++,/cuda/2021/07/17/GPU-Parallel-Chapter-1.html">&lt;h3 id=&quot;chapter-1-introduction-to-cpu-parallel-programming&quot;&gt;Chapter 1: Introduction to CPU Parallel Programming&lt;/h3&gt;

&lt;p&gt;The promise of Moore‚Äôs Law is dead (though not the Moore‚Äôs Law itself). The number of transistor‚Äôs on a chip are
increasing every 2 years, but the frequency increase has hit wall due to power consumption and heating issues.
So these new chips have more cores and for now it‚Äôs upto the programmers to get the best out of these multi-core systems.&lt;/p&gt;

&lt;h4 id=&quot;more-core-doesnt-directly-mean-more-performance&quot;&gt;More core doesn‚Äôt directly mean more performance&lt;/h4&gt;

&lt;p&gt;It is imperative to understand the fact that just because you make your program parallel doesn‚Äôt mean, it will be faster.
It is important to correctly orchestrate the work threads are doing. Also, with the fact the memory access being slower,
sometimes your program can get memory bound i.e. your cores are being underutilized and waiting for the data to be ready.
So parallel programming is mmore than just throwing more threads at your problem (unless it‚Äôs embarassingly parallel).&lt;/p&gt;

&lt;h4 id=&quot;data-bandwith-for-different-devies&quot;&gt;Data-bandwith for different devies&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Network Interface Card : 1Gbps (Gigabits per second)&lt;/li&gt;
  &lt;li&gt;HDD connected over PCI3 bus : 1-2 Gbps (6Gbps max possible)&lt;/li&gt;
  &lt;li&gt;USB 3 : Max 10Gbps&lt;/li&gt;
  &lt;li&gt;SSD over PCI3 bus : 4-5 Gbps (6Gbps max possible)&lt;/li&gt;
  &lt;li&gt;RAM : 20-60 GBps (Gigabytes per second) / 160-480 Gbps&lt;/li&gt;
  &lt;li&gt;GPU Internal Memory : 10-1000 GBps&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;interesting-note-from-the-book&quot;&gt;Interesting Note from the book&lt;/h4&gt;

&lt;p&gt;We can get less noisy performance/benchmark data if our data fits in cache because once data is in cache the execution
is fairly deterministic. However if data spills over the cache, then due to non-deterministic nature of memory access
from RAM (due to other programs running on OS and OS overheads) the benchmark data will be more noisy!&lt;/p&gt;</content><author><name>Kshiteej</name><email>kshitijkalambarkar@gmail.com</email></author><category term="c++," /><category term="cuda" /><summary type="html">Chapter 1: Introduction to CPU Parallel Programming</summary></entry><entry><title type="html">Contributing to Open Source Software (OSS) (Slide Deck)</title><link href="http://localhost:4000/oss/2021/04/29/contributing-to-oss-slide.html" rel="alternate" type="text/html" title="Contributing to Open Source Software (OSS) (Slide Deck)" /><published>2021-04-29T14:14:49+05:30</published><updated>2021-04-29T14:14:49+05:30</updated><id>http://localhost:4000/oss/2021/04/29/contributing-to-oss-slide</id><content type="html" xml:base="http://localhost:4000/oss/2021/04/29/contributing-to-oss-slide.html">&lt;h4 id=&quot;slide-preview&quot;&gt;Slide Preview&lt;/h4&gt;

&lt;p&gt;HackMD &lt;a href=&quot;https://hackmd.io/@kshiteejk/SJc65ipL_&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;contributing-to-open-source-software-oss&quot;&gt;Contributing to Open Source Software (OSS)&lt;/h4&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;who-am-i&quot;&gt;Who Am I?&lt;/h4&gt;

&lt;p&gt;&lt;span style=&quot;font-size:0.75em;&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Software Engineer at Quansight (developing PyTorch)&lt;/li&gt;
  &lt;li&gt;Contributed to PyTorch, MXNet, Chainer, etc.&lt;/li&gt;
  &lt;li&gt;Previously Machine Learning Engineer (in NLP and CV)&lt;/li&gt;
  &lt;li&gt;Not from CS background (only language university taught us was C üòî )&lt;/li&gt;
  &lt;li&gt;Learnt Python by wandering in the wild!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;/span&amp;gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;what-is-oss&quot;&gt;What is OSS?&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;brief-history&quot;&gt;Brief History&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Richard Stallman (pioneer)&lt;/li&gt;
  &lt;li&gt;Sharing your recipe&lt;/li&gt;
  &lt;li&gt;Imagine world without OSS üò®&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;does-anyone-even-use-it&quot;&gt;Does anyone even use it?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Recent Mars Ingenuity Helicopter&lt;/li&gt;
  &lt;li&gt;If you use Python&lt;/li&gt;
  &lt;li&gt;If you are using any cloud service&lt;/li&gt;
  &lt;li&gt;If you use Android&lt;/li&gt;
  &lt;li&gt;If you use ‚Ä¶.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;why-should-i-spend-my-time&quot;&gt;Why should I spend my time?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;People will use your code! üòÅ&lt;/li&gt;
  &lt;li&gt;Learning üìú&lt;/li&gt;
  &lt;li&gt;Ability to work in a team and interact! ü§ù&lt;/li&gt;
  &lt;li&gt;Meet new people! üë©‚Äçüíª&lt;/li&gt;
  &lt;li&gt;Get introduced to new tools and technologies (debuggers, linters)üîß&lt;/li&gt;
  &lt;li&gt;Might land a new job üíª&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;hopefully-you-are-interested-by-now-&quot;&gt;Hopefully you are interested by now ü§ì&lt;/h4&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;start-slow&quot;&gt;Start Slow&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;My experience&lt;/p&gt;

&lt;p&gt;First Pytorch PR terrible ü§¢&lt;/p&gt;

&lt;p&gt;Took 9 months to get accepted!
Lots of rookie mistakes!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Start Date&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/s7nRdXB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;End Date üéâ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/socFCiV.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;experience&quot;&gt;Experience&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Patience&lt;/li&gt;
  &lt;li&gt;Lot of learning&lt;/li&gt;
  &lt;li&gt;Got to interact with &lt;strong&gt;really&lt;/strong&gt; smart people&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tips&quot;&gt;Tips&lt;/h2&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;choosing-the-project-to-work-on&quot;&gt;Choosing the project to work on&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Personal Project that you really love&lt;/li&gt;
  &lt;li&gt;Some library that you use a lot (eg. NumPy, pandas)&lt;/li&gt;
  &lt;li&gt;Be sure to choose an active project&lt;/li&gt;
  &lt;li&gt;Project with developer guide and good documentation&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;things-to-remember&quot;&gt;Things to remember&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Ask for help! Nobody expects you to know everything&lt;/li&gt;
  &lt;li&gt;Be polite, humble and &lt;strong&gt;patient&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;There is no stupid question!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;thank-you&quot;&gt;Thank You!&lt;/h4&gt;

&lt;p&gt;Github Handle: kshitij12345
LinkedIn: kshiteejkalambarkar&lt;/p&gt;</content><author><name>Kshiteej</name><email>kshitijkalambarkar@gmail.com</email></author><category term="oss" /><summary type="html">Slide Preview</summary></entry><entry><title type="html">Gentle Introduction to Valgrind!</title><link href="http://localhost:4000/intro/2021/04/29/valgrind-intro.html" rel="alternate" type="text/html" title="Gentle Introduction to Valgrind!" /><published>2021-04-29T14:14:49+05:30</published><updated>2021-04-29T14:14:49+05:30</updated><id>http://localhost:4000/intro/2021/04/29/valgrind-intro</id><content type="html" xml:base="http://localhost:4000/intro/2021/04/29/valgrind-intro.html">&lt;h2 id=&quot;valgrind&quot;&gt;Valgrind&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.valgrind.org/downloads/&quot;&gt;Valgrind&lt;/a&gt; is an useful tool if you are working with C/C++. It is a suite of multipurpose tools with varied functionality. It allows you to detect memory-leak, profile your code and more. One of the thing that it shines at is helping debugging trick memory bug.&lt;/p&gt;

&lt;h3 id=&quot;how-does-it-work&quot;&gt;How does it work?&lt;/h3&gt;
&lt;p&gt;It is worth noting that Valgrind is language agnostic and works with all languages, compiled or interpreted. Since Valgrind consumes a binary, it does not care about which language it came from. Valgrind is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-intrusive&lt;/code&gt; in terms of adding an instrumentation code. You need not update your codebase for it to work with Valgrind. The way it manages to do this is by providing a virtual core for the binary to run on. This way it can also figure out statistics like number of number native instructions executed.&lt;/p&gt;

&lt;h3 id=&quot;installing-valgrind&quot;&gt;Installing Valgrind&lt;/h3&gt;
&lt;p&gt;Let‚Äôs start with setuping up a playground environment with Valgrind&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$conda&lt;/span&gt; create &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; valgrind-test-env
&lt;span class=&quot;nv&quot;&gt;$conda&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; conda-forge compilers
&lt;span class=&quot;nv&quot;&gt;$conda&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; conda-forge valgrind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-program&quot;&gt;Example Program&lt;/h3&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This innocuous looking program is actually ill-formed. The reason being, with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new[]&lt;/code&gt; allocation the allocated memory should be freed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;, with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; the behavior is undefined.&lt;/p&gt;

&lt;h3 id=&quot;building-the-program&quot;&gt;Building the program&lt;/h3&gt;
&lt;p&gt;Let‚Äôs build with most of the compiler warnings enabled to see if our compiler can foresee this issue and warn us.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g++ example.cc &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wpedantic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Werror&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wextra&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On running the following, we get a shiny new executable without any warnings.&lt;/p&gt;

&lt;h3 id=&quot;running-under-valgrind&quot;&gt;Running under Valgrind&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$valgrind --tool=memcheck ./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here we are asking Valgrind to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcheck&lt;/code&gt; on our binary. There are more tools and options which can be specified.&lt;/p&gt;

&lt;p&gt;On running the above command, we get the following output.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;==19750== Memcheck, a memory error detector
==19750== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==19750== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==19750== Command: ./a.out
==19750== 
==19750== Mismatched free() / delete / delete []
==19750==    at 0x403713B: operator delete(void*, unsigned long) (vg_replace_malloc.c:595)
==19750==    by 0x1091AD: main (in /home/user/Desktop/Repositories/valgrind-test/a.out)
==19750==  Address 0x51ccc80 is 0 bytes inside a block of size 10 alloc'd
==19750==    at 0x40365AF: operator new[](unsigned long) (vg_replace_malloc.c:433)
==19750==    by 0x109193: main (in /home/user/Desktop/Repositories/valgrind-test/a.out)
==19750== 
==19750== 
==19750== HEAP SUMMARY:
==19750==     in use at exit: 0 bytes in 0 blocks
==19750==   total heap usage: 2 allocs, 2 frees, 72,714 bytes allocated
==19750== 
==19750== All heap blocks were freed -- no leaks are possible
==19750== 
==19750== For lists of detected and suppressed errors, rerun with: -s
==19750== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mismatched free() / delete / delete []&lt;/code&gt;. The message tells us that we have a mismatched &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free() / delete / delete []&lt;/code&gt; for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new[]&lt;/code&gt;. Valgrind is able to detect this as it does the booking keeping of the instruction it executed, instructions which requested memory and instructions which freed it.&lt;/p&gt;

&lt;h2 id=&quot;caveats&quot;&gt;Caveats&lt;/h2&gt;
&lt;p&gt;Since Valgrind emulates the hardware and does more tracking and bookkeeping, running a program under Valgrind is much slower.&lt;/p&gt;

&lt;p&gt;Valgrind‚Äôs site states&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;So what's the catch? The main one is that programs run significantly more slowly under Valgrind. Depending on which tool you use, the slowdown factor can range from 5--100. This slowdown is similar to that of similar debugging and profiling tools. But since you don't have to use Valgrind all the time, this usually isn't too much of a problem. The hours you'll save debugging will more than make up for it.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;epilogue&quot;&gt;Epilogue&lt;/h2&gt;

&lt;p&gt;All in all, Valgrind is worthwhile tool to catch bugs. Even though it is slow, it will cut down on the debugging time by a large margin.&lt;/p&gt;</content><author><name>Kshiteej</name><email>kshitijkalambarkar@gmail.com</email></author><category term="intro" /><summary type="html">Valgrind Valgrind is an useful tool if you are working with C/C++. It is a suite of multipurpose tools with varied functionality. It allows you to detect memory-leak, profile your code and more. One of the thing that it shines at is helping debugging trick memory bug.</summary></entry></feed>